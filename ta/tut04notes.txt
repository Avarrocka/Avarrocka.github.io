++++++++++++ CSCA48 Tutorial 04 ++++++++++++

Today we introduced the concept of Trees. We focused on Binary Trees in particular.

-------------------------------------------------------
Binary Trees
-------------------------------------------------------
Binary Trees are data structures that have three things:

- A value		int, str, etc.	
- A left child		Node
- A right child		Node

We can imagine a binary tree to look like:
	[5]
        / \
      [4] [6]

We define some specific terminology regarding trees:
- The depth of a node is the number of edges from the root to the node.
- The height of a node is the number of edges from the node to the deepest leaf.
- The height of a tree is a height of the root.
- A full binary tree.is a binary tree in which each node has exactly zero or two children.
- A complete binary tree is a binary tree, which is completely filled, with the possible exception of the bottom level, which is filled from left to right.
-------------------------------------------------------

We take a look at three different tree traversals:
Pre-order, In-order, and Post-Order traversals.
I like to think of the name as of where to put the 'Node'. For example, we always have
Left Right
For Pre, we put the Node _before_ the Left Right, so we get Node, Left, Right.
For In, we put the Node _between_ the Left Right, so we get Left, Node, Right.
For Post, we put the Node _after_ the Left Right, so we get Left, Right, Node.

Let us consider the following binary tree:
        2
       / \
      /   \
     /     \
    1       3
   / \     / \
  0   7   9   1
 /   / \     / \
2   1   0   8   8

---- PREORDER TRAVERSAL ----
We can think of Pre-order traversals as Node, Left, Right.
So for each node, we first record the node value, then the left node's preorder traversal, then the right node's preorder traversal.

The preorder traversal for the above tree would be:
2 1 0 2 7 1 0 3 9 1 8 8

---- IN ORDER TRAVERSAL ----
We can think of In-order traversals as Left, Node, Right.
So for each node, we first record the left node's preorder traversal, then the node's value, then the right node's preorder traversal.

The preorder traversal for the above tree would be:
2 0 1 1 7 0 2 9 3 8 1 8

---- POST ORDER TRAVERSAL ----
We can think of Post-order traversals as Left, Right, Node.
So for each node, we first record the left node's preorder traversal, then the right node's preorder traversal, then the node's value.

The preorder traversal for the above tree would be:
2 0 1 0 7 1 9 8 8 1 3 2

We then introduced the idea of Breadth first and Depth first searches. Imagine having a container and running this code:

def BFSorDFS(head):
 my_container.put(head)
 while(not container.is_empty()):
  next_node = container.get()
   print(next_node)
   for each child:
    container.put(child)

Let us look at the above binary tree again. If we use a Queue, a first-in-first-out container, we would visit:
2 then 1, 3 then 0, 7, 9, 1 then 2, 1, 0, 8, 8. Notice how it evaluates each 'layer' of the tree before proceeding to the next depth layer. This would be a... breadth first search!

Let us consider what happens if we use a Stack, a first-in-last-out container. We would visit: 2 1 0 2 7 1 0 3 9 1 8 8. Notice how it goes to the maximum depth first. This is a... depth first search!


EOF