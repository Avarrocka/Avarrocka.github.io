++++++++++++ CSCA48 Tutorial 01 ++++++++++++

Welcomed everyone back. Anyone still missing CSCA08 knowledge should attend practicals to review, or check out Harrington's site to review key concepts. We'll jump right into A48.

We learned about implementation of Stacks and reviewed ADT.

We can implement a 'Stack' abstract data type [ADT] having the First in, Last out, or FILO principle (think about a stack of pancakes. First pancake on the plate is the last to be eaten). We can do this in Python in a few different ways...



class Stack:
    '''A last-in, first-out (LIFO) stack of items'''
    
    def __init__(self):
        '''(Stack) -> NoneType
        Create a new, empty stack.
        '''
        self._contents = []
        
    def push(self, new_obj):
        '''(Stack, object) -> NoneType
        Place new_obj on top of this stack.
        '''
        self._contents.append(new_obj)

    def pop(self):
        '''(Stack) -> object
        Remove and return the top item in this stack.
        '''
        return self._contents.pop()
    
    def is_empty(self):
        '''(Stack) -> bool
        Return True iff this stack is empty
        '''
        
        return self._contents == []
        #could have also done
        # return len(self._contents) == 0

class StackB:
    '''A last-in, first-out (LIFO) stack of items'''

    def __init__(self):
        '''(Stack) -> NoneType
        Create a new, empty Stack.
        '''

        self._contents = []

    def push(self, new_obj):
        '''(Stack, object) -> NoneType
        Place new_obj on top of this stack.
        '''
		#Store the item to the beginning of the list
		#(this is a bad idea, but we're doing it anyway)
        self._contents.insert(0, new_obj)

    def pop(self):
        '''(Stack) -> object
        Remove and return the top item in this stack.
        '''

        return self._contents.pop(0)
        
    def is_empty(self):
        '''(Stack) -> bool
        Return True iff this stack is empty.'''

        return self._contents == []
    
class StackC:
    '''A last-in, first-out (LIFO) stack of items'''
    
    def __init__(self):
        '''(Stack) -> NoneType
        Create a new, empty stack.
        '''
        #we're going to store the stack as a dictionary {k:v}
        #where k = height on stack, v = value
        self._contents = {}
        self._height = 0
        
    def push(self, new_obj):
        '''(Stack, object) -> NoneType
        Place new_obj on top of this stack.
        '''
        self._contents[self._height] = new_obj
        self._height +=1

    def pop(self):
        '''(Stack) -> object
        Remove and return the top item in this stack.
        '''
        #to pop, we don't actually need to remove the items from
        #the dictionary, as any further push will simply over-write
        #the next key, and we're using height to check for emptiness
        self._height -=1
        return self._contents[self._height]
        
    
    def is_empty(self):
        '''(Stack) -> bool
        Return True iff this stack is empty
        '''
        #this is a good example of where we need to know how the rest of the code
        #in our class works, if we used return self.contents == {}
        #it would fail, because of the way we implemented pop
        return self._height == 0




We then took a look at a function that implements a specific Stack. We noted that we dont really care about the particulars of HOW WE MADE Stack, but really only that it works under the Stack properties. We did a simple Decimal-to-Binary calculating algorithm.


from my_stacks import StackA
def convert_to_binary(decimal_number):
    '''(int) -> str
    
    Return a string representing demical_number in binary
    
    '''
    #This stack will hold the remainders of the divisions,
    #which will eventually become the binary string
    remainder_stack = Stack()
    
    #while decimal_number is greater than zero, keep dividing it by 2 (using
    #integer division) and pushing the remainder onto the stack. This will 
    #result in the stack becoming a binary representation (read top to bottom) 
    #of the original decimal_number
    while(decimal_number > 0):
        remainder = decimal_number % 2
        remainder_stack.push(remainder)
        decimal_number = decimal_number // 2

    #the stack, read from top to bottom is now the binary number we want to
    #return. So we simply pop each item and add it (as a string) to the 
    #return value
    binary_string = ""
    
    while(not (remainder_stack.is_empty())):
          binary_string += str(remainder_stack.pop())
    
    return binary_string

if (__name__ == "__main__"):
    print(convert_to_binary(42))
    print(convert_to_binary(13452))



EOF