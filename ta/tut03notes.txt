++++++++++++ CSCA48 Tutorial 03 ++++++++++++

We reviewed the idea of Linked Lists
Quiz Topic: 
-------------------------------------------------------
Linked Lists
-------------------------------------------------------
A type of list structure that is defined by Linked List Nodes (LLNodes). Imagine a node that has two things: a value, and a pointer to the next node. These would form a 'line' or a 'string' of linked list nodes, or a linked list.

A LLNode by itself looks like this:
[Value]--->None
An example of a linked list is:
 v The 'Head' LLNode		      v The 'Tail' LLNode
[3]--->[4]--->[1]--->[10]--->[12]--->[15]--->None
    ^ Pointer to next Node		      ^ Last node always points to None to indicate end of Linked list.
-------------------------------------------------------

Then we introduced a doubly-linked-list.

-------------------------------------------------------
Doubly Linked Lists
-------------------------------------------------------
Instead of just having a node pointing to the next node in order, we also have a pointer to the previous node too. We motivated this by examples of things like a 'Back' button in your browser, or an 'undo' button.

A standalone node now looks like this:
None<---[Value]--->None
An example of a doubly linked list is:
           --->	  --->
None<---[3]    [4]    [5]--->None
           <---   <---
-------------------------------------------------------

We can call head.next.next.prev to get the value of 4. Because we have head = [3], head.next = [4], and head.next.next = [5], then head.next.next.prev = [4].

_______________________________________________________

Implementation
_______________________________________________________
class DLLNode(object):
    """A Node in a doubly-linked list"""

    def __init__(self, data, prev_link=None, next_link=None):
        '''(DLLNode, object, DLLNode, DLLNode) -> NoneType

        Create a new DLLNode containing object, with previous node
        prev_link, and next node next_link.
        '''
        # Representation invariant:
        # data is an object
        # prev_link is a DLLNode
        # next_link is a DLLNode
        # data is the item held in this node
        # prev_link is the node immediately before (closer
        # to the head of the list than) this node
        # next_link is the node immediately after (closer
        # to the tail of the list than) this node

        self.data = data
        self.prev_link = prev_link
        self.next_link = next_link

    def __str__(self):
        '''(DLLNode) -> str
        Return a str representation of this DLLNode.
        '''

        return str(self.data)


class DoublyLinkedList(object):
    """A doubly linked list"""

    def __init__(self):
        '''(DoublyLinkedList) -> NoneType
        Create a new empty DoublyLinkedList
        '''
        # Representation invariant:
        # _head is a DLLNode
        # _tail is a DLLNode
        # if the list is empty:
        #     _head = _tail = None
        # if the list is non-empty:
        #     _head is the first node in the list
        #     _tail is the last node in the list
        #     if nodeA and nodeB are both nodes in this list and nodeA is
        #     before (closer to the head than) nodeB:
        #         nodeA.next_link[.next_link]* = nodeB
        #             ([.next_link]* = 0 or more repetitions of .next_link)
        #         nodeB.prev_link[.prev_link]* = nodeA
        self._head = None
        self._tail = None

    def __str__(self):
        '''(DoublyLinkedList) -> str

        Return a str representation of the contents of this
        DoublyLinkedList.
        '''
        curr = self._head
        while(curr):
            print(curr)
            curr = curr.next_link

    def add_head(self, add_obj):
        '''(DoublyLinkedList, object) -> NoneType
        Add add_obj to the head of this DoublyLinkedList.
        '''
        # If nothing exists in this linked list
        if(self._head is None):
            self._head = add_obj
            self._tail = add_obj
        # If a head already exists, we append to before that head and change it
        else:
            self._head.prev_link = add_obj
            add_obj.next_link = self._head
            self._head = add_obj

    def add_tail(self, add_obj):
        '''(DoublyLinkedList, object) -> NoneType
        Add add_obj to the tail of this DoublyLinkedList.
        '''
        # If nothing exists in this linked list
        if(self._tail is None):
            self._head = add_obj
            self._tail = add_obj
        else:
            self._tail.next_link = add_obj
            add_obj.prev_link = self._tail
            self._tail = add_obj

    def remove_head(self):
        '''(DoublyLinkedList) -> object
        Remove and return the first item in this DoublyLinkedList.
        '''

        pass

    def remove_tail(self):
        '''(DoublyLinkedList) -> object
        Remove and return the last item in this DoublyLinkedList.
        '''
        prev = self._tail.prev_link
        prev.next_link = None
        self._tail = prev

    def add_index(self, add_obj, add_index):
        '''(DoublyLinkedList, object, int) -> NoneType
        Add add_obj to this DoublyLinkedList at index add_index.
        '''
        ind = 0
        curr = self._head
        while(curr):
            if(ind < add_index):
                # This node now points to next object
                curr.next_link.prev_link = add_obj
                add_obj.next_link = curr.next_link
                # Previous now points to this node
                curr.next_link = add_obj
                add_obj.prev_link = curr

            else:
                ind = ind + 1
                curr = curr.next_link
        

    def remove_index(self, remove_index):
        '''(DoublyLinkedList, int) -> object

        Remove and return the item at index remove_index in this
        DoublyLinkedList.
        '''

        pass


EOF