++++++++++++ CSCA48 Tutorial 06 ++++++++++++

Quiz Topic: Min-heaps

Funny recursion collage --> byxc.me/ta/recursion.png

Today we went over a cursory introduction to the idea of Recursion. Recursion is a problem-solving strategy. Think of it as a divide-and-conquer approach to solving a problem. If a problem looks to be very very large, or can be solved through successive repetitions of the same logic, we can and should use recursion. What are some applications of this? Proof by induction!

We consider several interesting applications of recursion. Whats one problem that we can break down into smaller problems? The fibonacci sequence!

Think of it this way:
Each fib sequence is the sum of its two previous ones. So to get the seventh, we calculate the sixth and fifth, for the sixth, we calculate the fifth and fourth... and so on. Before we begin, we learn a bit about properties of recursion:

When we want to use recursion to solve a problem, we define some BASE CASES. These are the smallest step of the problem -- once we reach them, we can't go any deeper! So, for the fib sequence, we know that the base cases are when fib(0) = 1, fib(1) = 1. Given these, we can generate the rest of the fibonacci sequence up to any number! We can think of these questions as the fundamental questions of recursion:

FIBONACCI EXAMPLE
-----------------------------------------------------
What are the base cases of factorial? 
	fib(0) = 1, fib(1) = 1
How do we get each successive term? 
	fib(n-1) + fib(n-2)

def fib(n):
    if(n < 2):
        result = 1
    else:
        a = fib(n-1)
        b = fib(n-2)
        result =  a + b
    return result
    
if(__name__ == "__main__"):
    print(fib(5))

FACTORIAL EXAMPLE
-----------------------------------------------------
What are the base cases of factorial? 
	fac(1) = 1
How do we get each successive term? 
	n * fac(n-1).

def fac(n):
    if(n ==1):
        result = 1
    else:
        result = n * fac(n-1)
    return result

REVERSE LINKED LIST EXAMPLE
-----------------------------------------------------
What are the base cases of reverse?
	when node.next = None (tail of orig. list)
How do we get to each successive term?
	(reversed-node).(original-next)

def reverse (item --> LLNode, tail = None):
    next = item.next
    item.next = tail
    if next is None:
        return item
    else:
        return reverse(next, item)

EOF