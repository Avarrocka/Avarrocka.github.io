++++++++++++ CSCA48 Tutorial 02 ++++++++++++

This week we’re going to go through the process of creating a new container. The Deque, or double ended queue. Basically it’s just a queue where you can enqueue and dequeue from either end (really useful for cases where you want to have high-priority items like job scheduling, or for an undo/redo feature to keep track of operations).

First off, Deque is NOT 'De-Queue' (the operation). Its pronounced 'deck' and is just a (d)ouble (e)nded queue, or d.e.queue. Imagine a line down the middle representing the current amount of Contents in your queue. You can either add from:
The left: ITEM + [Contents]
The right: [Contents] + Item

We considered what to make of the Representational Invariant.

-------------------------------------------------------
ADDITIONAL NOTES
-------------------------------------------------------
"A representation invariant is a way to describe how the variables of a
  class represent the data of the ADT that the class implements.  It is
  written as a true/false statement, which should be true when an instance
  of the class is created, as well as after every method call."

For example, for example, lets have an ADT representing a deck of cards.

Representation invariant:
        _deck is a list of card objects
        _deck[:] is the list of cards with deck[0] being the card at the top of the pile, and _deck[51] being the card at the bottom of the pile

A more practical example, the Representative Invariant of a standard Queue:

Representation invariant:
        _contents is a list.
        len(_contents) is the number of elements in me.
        If len(_contents) > 0, then
          _contents[0] is the head,
          _contents[-1] is the tail,
          _contents[:] contains
           the elements in the order they were inserted.
        self._contents = []

-------------------------------------------------------

Let us now consider the Representational Invariant of a Deque.

Representation invariant:
	_contents is a list of object.
	_contents[:] are the objects in the dequeue.
        if i < j, i >=0, j < len(_contents), then
            _contents[i] is to the left of _contents[j] in the deque
            _contents[j] is to the right of _contents[i] in the deque



We considered how to implement this. One implementation could be:

class EmptyQueueError(Exception):
    '''An error to be raised when someone tries to dequeue from an empty queue'''

class Deque():
    '''A double ended queue'''

    def __init__(self: 'Deque') -> None:
        # Representation invariant:
        # _contents is a list of object.
        # _contents[:] are the objects in the dequeue.
        # if i < j, i >=0, j < len(_contents), then
        #    _contents[i] is to the left of _contents[j] in the deque
        #    _contents[j] is to the right of _contents[i] in the deque

        self._contents = []

    def enqueue_left(self: 'Deque', item: 'object') -> None:
        '''
        Add item onto the left side of the deque
        '''
        self._contents = [item] + self._contents

    def enqueue_right(self: 'Deque', item: 'object') -> None:
        '''
        Add item onto the right side of the deque
        '''
        self._contents = self._contents + [item]

    def dequeue_left(self: 'Deque') -> object:
        '''
        Remove and return the leftmost item in the deque
        '''
        if(self.is_empty()):
            raise EmptyQueueError("Can't dequeue from an empty queue")
        else:
            item = self._contents[0]
            self._contents = self._contents[1:]
            return item

    def dequeue_right(self: 'Deque') -> object:
        '''
        Remove and return the rightmost item in the deque
        '''
        if(self.is_empty()):
            raise EmptyQueueError("Can't dequeue from an empty queue")
        else:
            item = self._contents[-1]
            self._contents = self._contents[:-1]
            return item

    def is_empty(self: 'Deque') -> bool:
        '''
        Return True iff this deque is empty
        '''
        return len(self._contents) == 0
    
    def get_deque(self: 'Deque') -> list:
        '''
        Returns the representative list of this deque
        '''
        return self._contents

if(__name__ == "__main__"):
    dq = Deque()
    dq.enqueue_left('A')
    dq.enqueue_left('B')
    dq.enqueue_left('C')
    dq.enqueue_right('D')
    dq.enqueue_right('E')
    dq.enqueue_right('F')
    print(dq.get_deque())
    while(not dq.is_empty()):
        print(dq.dequeue_right())
        print(dq.dequeue_left())

That was more or less it. Representative Invariants are indeed confusing, so make sure to fully understand them! For more reading on Representative Invariant, check out:
  http://www.utsc.utoronto.ca/~nick/CSCA48/queue3.py
  http://www.utsc.utoronto.ca/~nick/CSCA48/queue4.py
  http://www.utsc.utoronto.ca/~nick/CSCA48/stack1.py
  http://www.utsc.utoronto.ca/~nick/CSCA48/stack2.py
  http://www.utsc.utoronto.ca/~nick/CSCA48/#week01
  https://www.cs.cmu.edu/~rwh/introsml/techniques/repinv.htm
  
EOF